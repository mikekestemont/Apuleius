1.	Use the Migration Assistant to identify obsolete functions and events. The Migration Assistant scans PowerBuilder libraries to detect potential problems with syntax prior to migrating the application. Obsolete Syntax is available from version 6 onwards. The Migration Assistant can be found on the "Tool" tab of the "New" object dialogue box.   2.	PSR files, if an application attempts to open a PSR file created in an earlier version of PowerBuilder (pre 8.0 build 7063 or pre 7.0 build 10102) it will fail. This is due to a change in the SaveAsASCII function. To fix this problem, recreate the PSR in a later build of PowerBuilder.   3.	New reserved words (Try, Catch, Finally, Throw, Throws) were introduced in PowerBuilder 8.0 for exception handling. The Migration Assistant will identify any occurrences of these reserved words. To fix this problem, change all the instances of "Try, Catch, Finally, Throw, Throws" in your application to alternative names using a previous version of PowerBuilder.   4.	Distributed programming support has been discontinued since PowerBuilder 8.0. The "Transport" object has become obsolete. The application events "connectionbegin" and "connectionend" no longer get fired. The solution is to deploy your server side NVOs to EAServer.  5.	SystemError Event processing has changed between PowerBuilder 7 and the later versions of PowerBuilder. In PowerBuilder 7, when an error occurs the "SystemError" event is triggered, after the "SystemError" event processing has completed, control is returned to the script where the error occurred. In PowerBuilder 8 and 9, when an error occurs the call stack is unwound, then the "SystemError" event is triggered, after the "SystemError" event processing has completed, processing does NOT continue at the point where the error occurred. Catch and handle errors locally using the new exception handling functionality available in PowerBuilder 8 and 9.   6.	IsValid function was changed in PowerBuilder 8 to return "FALSE" if the object is not instantiated or an invalid object has been passed, prior to version 8, if an invalid object was passed the "SystemError" event would be triggered.   7.	Windows no longer inherit the Application Icon, you must now code or set the property to AppIcon!"   8.	TreeView Event, the "rbuttonup!" event no longer fires, this was introduced in PowerBuilder 7 that comes with Microsoft's Treeview and Listview controls.	  9.	ListView, the "pbm_rbuttonup!" event no longer fires when rightclicking on a ListView item, but it does fire if you click on the white area in the ListView. The solution to this is to use the new "pbm_contextmenu!" event, which always fires when the right mouse button is released.   10.	Web Targets that use the WebDataWindow control must be modified to use the new HTMLGenerator90 component. Right click on the Web DataWindow Design Time Control on your web page and select properties. On the "HTML Generator" tab change the reference from HTMLGenerator80 to HTMLGenerator90. After changing the HTMLGenerator, the database connection properties are sometimes lost, so it is important to check the "Connection" tab and ensure that the database connection setting is still correct after the change.   11.	Another issue while migrating from PowerBuilder 6.5 to PowerBuilder 9 is that the compiler in PowerBuilder 7 and above needs to validate the existence of the graphic files. In PowerBuilder 6.5, the compiler continues compilation even if the file is not found but in v7 and above, we get warnings and even the compilation may stop abruptly because it cannot find the graphic file.  PowerBuilder Foundation Classes  You must 'replace' the PFC libraries with those from PowerBuilder 9 to start with. However, if you are not using the PFE libraries that came with PowerBuilder 9 due to your own customizations to the e-level or an intermediate corp-layer (I hate intermediate corp-layers inserted between PFC and PFE), here are some issues to address:   OBSOLETE OBJECTS:   PFCAPSRV.pbl  pfc_n_cst_FileSrvMAC (7.0) pfc_n_cst_FileSrvWin16 (7.0) pfc_n_cst_PlatformMAC (7.0) pfc_n_cst_PlatformWin16 (7.0)    PFEAPSRV.pbl  n_cst_FileSrvMAC  n_cst_FileSrvWin16  n_cst_PlatformMAC  n_cst_PlatformWin16   PFCMAIN.pbl  pfc_n_Trp   PFEMAIN.pbl  n_Trp   NEW OBJECTS:   PFEAPSRV.pbl  pfc_n_cst_FileSrvUnicode (6.02) pfc_n_cst_PlatformUnicode (6.02)   PFCDWSRV.pbl  pfc_n_cst_dwcacheattrib  pfc_n_cst_trregistrationattrib  pfc_n_cst_dwsrv_resizeattrib  pfc_n_cst_dwsrv_querymodeattrib  pfc_n_cst_dwsrv_multitableattrib  pfc_n_cst_dwsrv_dropdownsearchattrib  pfc_n_cst_dssrv_multitableattrib   PFCMAIN.pbl  pfc_n_cst_tvattrib   PFCWNSRV.pbl  pfc_n_cst_resizeattrib  pfc_n_cst_winsrv_sheetmanagerattrib  pfc_n_cst_winsrv_statusbarattrib  Blow off all the OBSOLETE objects from PFC/PFE. Inherit all the NEW objects in PFC into PFE/corp-layer.       Note: I got this from one discussion group: I don't remember which one.
C#    Once we decided to use the IE treeview control the hierarchical data, the problem was how to populate it. We had to display several hirarchies, but the number of levels was not fixed. For example - the product hirarchy had two levels: Product Family and Product; the Geography hierarchy had three levels: Country, State and County.  We needed a generic function which will create the tree, no matter how many levels there are. The following code is the solution I came up with.  We'll take the geography hierarchy as the example. The public function takes a DataSet as the parameter. You have to fill the dataset with three tables - Country, State and County. Be sure to assign the names to the table. Then set the relationship between the tables. Pass the dataset to the public function. That's all!   Each node of the tree will be displayed as Code - Description. For example - "IN - India". The type of the node (NodeType) will be the table name.   Do let me know if you have any comments.                    ///     &lt;   summary   &gt;             ///   This function creates a tree from a dataset. The function creates the first level nodes              ///   and then passes control to the recursive CreateTree function to create the child nodes.             ///   The names of the tables in the dataset and their relationships should be specified.             ///   If there are n tables in the dataset, the function expects n-1 relationships.           ///     &lt;/   summary   &gt;           ///     &lt;   param       name  = &quot;dsTreeData&quot;  &gt;  &lt;/   param   &gt;            public     void   CreateTree(DataSet dsTreeData)         {                 myTreeView.Nodes.Clear();                   foreach  (DataRow row in dsTreeData.Tables[ 0 ].Rows)                 {                         TreeNode treeNode = CreateNode(row[ 0 ] +  &quot; - &quot;  + row[ 1 ],                         									row[ 0 ].Tostring(),                          									dsTreeData.Tables[ 0 ].TableName);                         myTreeView.Nodes.Add(treeNode);                           if   (dsTreeData.Tables.Count &gt;  1 )                         {                                 CreateTree(row.GetChildRows(dsTreeData.Relations[ 0 ].RelationName),                                  0 ,                                 treeNode,                                  dsTreeData);                         }                 }           }            ///     &lt;   summary   &gt;             ///   Recursive function which actually creates the tree.             ///     &lt;/   summary   &gt;           ///     &